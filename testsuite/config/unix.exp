
set timeout 2

proc xs_exit {} {
	send "exit\r"
}
proc xs_version {} {}
proc xs_load {arg} {}

proc xs_force_restart {} {
    exec kill -9 [exp_pid]
    # This will probably fail due to already closed
    catch {close}
    wait
    xs_start 
}

# This is admittedly imperfect when sending weird characters
# where just using send is preferable
# Also, don't pass anything that starts with '-'
proc xs_send {string} {
    global test
    send "\r$string\r"
    expect {
        -ex "$string"         {}
        timeout               { fail "Timed out waiting for echo on: $test\r" }
    }
}

proc verify_alive {} {
    global test
    flush
    if [catch { xs_send "echo _alive" } msg] {
            fail "Send failed (xs probably died):\r $test: $msg"
            xs_force_restart
    } else {
        expect {
            -ex "_alive"          { pass "$test" }
            timeout               { fail "Caused xs hang: $test"; 
                                    xs_force_restart }
        }
    }
    flush
}

proc flush {} {
    send "matchdone\r"
    expect { 
        "_tmatchdone3X\r\n;" {}
        timeout         { force_restart_xs }
    }
}
proc xs_match {answer} {
    global test
    global prompt
    expect "$answer"          { verify_alive } \
        timeout               { fail "Timed out: $test"; xs_force_restart }
    
    flush
}
proc xs_match_re {answer} {
    global test
    global prompt
    expect -re "$answer"          { verify_alive } \
        timeout               { fail "Timed out: $test"; xs_force_restart }
    
    flush
}  

proc xs_start {} {
	global XS
	global spawn_id
    global prompt
    set prompt ";"
	send_user "Starting $XS\r"
	spawn $XS
	expect {
		-re ".*; " { }
		-re "No such file.*" { perror "Can't start $XS"; exit 1 }
		timeout { perror "Failed to spawn xs (timeout)"; exit 1 }
	}
	send "prompt:=';'\r" 
    expect {
        "prompt:=';'" {}
    }
    set fndef "fn matchdone { echo _tmatchdone3X }\r";
    send $fndef
    expect "$fndef"
}

xs_start
