#! /usr/local/bin/xs --

pgm = $0
file = $1
start = $2; ~ $start () && start = 1

~ $1 --help && {
	cat <<EOF
usage: $pgm FILE [START_PAGE]

A markup command begins each line of FILE:
.h Header text (one line)
.s Subheader text (one line)
.f Footer text (one line)
.i indent amount (number of leading blanks)
.j subsequent indent amount (additional leading blanks on subsequent lines)
.w line width (0 to use terminal width)
.p Paragraph text (end with a completely blank line)
.b Block (literal, nowrap) text (end with a completely blank line)
.^ Page break; pause for key

Navigation
  next slide:     n f j h <tab> <space> <enter>
  previous slide: p b k l ` <backspace> <delete>
  redraw:         r
  exit:           q .
EOF
	exit 1
}

~ $#* 0 && throw error `{basename $pgm} 'file [START_PAGE]'

let (header; subheader; footer; rows; rc; width = `{tput cols}; \
		 pn = 1; indent = ''; sindent = ''; text = '') {

	fn indent {|n|
		for i `{seq $n} {printf ' '}
	}

	fn fill {|t|
		printf $indent
		let (wl = <={%split ' ' $t}; wc; \
				cw = <={$&wid $indent}) {
			for w $wl {
				wc = <={$&wid $w}
				if {`($wc+$cw) :ge $width} {
					printf \n%s $indent^$sindent
					cw = <={$&wid $indent^$sindent}
					rc = `($rc+1)
				}
				printf '%s ' $w
				cw = `($cw+$wc+1)
			}
		}
		printf \n\n
		rc = `($rc+2)
	}

	fn render {|pars|
		let (pt = <={%split \n $pars}; ob = false) {
			for t $pt {
				let ((w1 lr) = <={~~ $t *\ *}) {
					if {~ $w1 .b} {
						ob = true
						printf '%s%s'\n $indent $lr
						rc = `($rc+1)
					} else if {~ $w1 .i} {
						indent = ' '$lr
					} else if {~ $w1 .j} {
						sindent = ' '$lr
					} else if {~ $w1 .w} {
						width = $lr
						~ $width 0 && \
							width = `{tput cols}
					} else {
						if $ob {
							printf \n
							rc = `($rc+1)
							ob = false
						}
						fill $t
					}
				}
			}
		}
	}

	fn redraw {|page|
		indent = ''
		text = ''
		width = `{tput cols}
		exec $pgm $file $page
	}

	fn waitkey {
		let (kc) {escape {|fn-done| {while (true) {
			kc = <={%without-echo %read-char}
			if {~ $kc \b \x7f p b k l \`} {redraw `($pn-1)}
			if {~ $kc r} {redraw $pn}
			if {~ $kc ' ' \n n f j h \t} {done}
			if {~ $kc q .} {exit}
		}}}}
	}

	fn showpage {
		rows = `{tput lines}
		clear
		printf %s%s%s\n <=.%ab <={%argify $header} <=.%an
		printf %s%s%s\n <=.%ai <={%argify $subheader} <=.%an
		printf \n
		rc = 5
		render $text
		while {$rc :lt $rows} {
			printf \n
			rc = `($rc+1)
		}
		printf '%s[%3d] %s%s'\n <=.%ad $pn <={%argify $footer} <=.%an
		waitkey
		pn = `($pn+1)
		text = ''
	}

	%without-cursor \
	%with-read-lines $file {|line|
		let ((w1 lr) = <={~~ $line *\ * *}) {
			switch $w1 (
			'.h' {header = $lr}
			'.s' {subheader = $lr}
			'.f' {footer = $lr}
			'.i' {text = $text^\n.i^`` '' {indent $lr}^\n}
			'.j' {text = $text^\n.j^`` '' {indent $lr}^\n}
			'.w' {text = $text^\n.w' '^<={%argify $lr}^\n}
			'.p' {text = $text^' '^$lr}
			'.b' {text = $text^\n.b' '^$lr\n}
			'.^' {if {$start :gt $pn} {
					text = ''
					pn = `($pn+1)
				} else {
					showpage
				}}
			{text = $text^\n}
			)
		}
	}
}
